//================================================
//
//パーティクル処理[paticle.cpp]
// Author; miura yuudai
//
//================================================

//=================================================
//インクルード読み込み
//=================================================
#include "particle.h"
#include "effect.h"
#include "manager.h"
#include "Renderer.h"

//=============================================================================
//静的メンバ変数宣言
//=============================================================================
LPDIRECT3DTEXTURE9 CParticle::m_pTexture = NULL;

//=============================================================================
//コンストラクタ
//=============================================================================
CParticle::CParticle()
{

}

//=============================================================================
//デストラクタ
//=============================================================================
CParticle::~CParticle()
{

}

//=============================================================================
//パーティクルの初期化処理
//=============================================================================
HRESULT CParticle::Init(D3DXVECTOR3 pos, float fHight, float fWidth,D3DXCOLOR col,PARTICLE particle)
{
	//初期化処理
	CEffect::Init(pos, fHight, fWidth, col,CEffect::EFFECTTYPE_NONE);

	//移動量の初期化
	m_move = D3DXVECTOR3(0.0f,0.0f,0.0f);
	m_nLife = 5 + rand() % 7;

	if (particle == PARTICLE_ENEMY)
	{
		//カラー変更関数呼び出し
		SetCol(col);

		//moveの計算処理
		m_fAngle = (float)(rand() % 100 - 50) / 100.0f;
		m_move.x = sinf(m_fAngle * D3DX_PI) * 10.5f;
		m_move.y = cosf(m_fAngle * D3DX_PI) * 10.5f;
	}
	else if(particle == PARTICLE_PLAYER)
	{
		//カラー変更関数呼び出し
		SetCol(col);

		//moveの計算処理
		m_fAngle = (float)(rand() % 628 + 314) / 100.0f;
		m_move.x = sinf(m_fAngle * D3DX_PI) * 10.5f;
		m_move.y = cosf(m_fAngle * D3DX_PI) * 10.5f;
	}

	//返り値
	return S_OK;
}

//=============================================================================
//パーティクルの設定・更新処理
//=============================================================================
CParticle * CParticle::Create(D3DXVECTOR3 pos,D3DXCOLOR col,PARTICLE particle)
{
	//インスタンス生成
	CParticle *pParticle = NULL;
	pParticle = new CParticle;

	//初期化呼び出し
	pParticle->Init(pos, MAX_PARTICLE_SIZE, MAX_PARTICLE_SIZE,col,particle);

	//テクスチャ呼び出し
	pParticle->BindTexture(m_pTexture);

	//返り値
	return pParticle;
}
//=============================================================================
//パーティクルの終了処理
//=============================================================================
void CParticle::Uninit(void)
{
	//基本クラスの終了処理
	CEffect::Uninit();
}
//=============================================================================
//エフェクトの更新処理
//=============================================================================
void CParticle::Update(void)
{
	//弾の処理関数呼び出し
	SetParticleMove();
}
//=============================================================================
//エフェクトの描画処理
//=============================================================================
void CParticle::Draw(void)
{
	//基本クラスの描画処理
	CEffect::Draw();
}
//=============================================================================
//エフェクトのテクスチャ処理
//=============================================================================
HRESULT CParticle::Load(void)
{
	// 頂点情報を設定
	LPDIRECT3DDEVICE9 pDevice;

	//デバイスの取得
	pDevice = CManager::GetRenderer()->GetDevice();

	//テキスチャの読み込み
	D3DXCreateTextureFromFile(pDevice, "data/TEXTURE/effect000.jpg", &m_pTexture);

	return S_OK;
}
//=============================================================================
//エフェクトのテクスチャの廃棄処理
//=============================================================================
void CParticle::Unload(void)
{
	//テクスチャの開放
	if (m_pTexture != NULL)
	{
		m_pTexture->Release();
		m_pTexture = NULL;
	}
}
//=============================================================================
//エフェクトの移動処理
//=============================================================================
void CParticle::SetParticleMove(void)
{
	//値を代入
	m_pos = GetPosition();

	//位置更新
	m_pos += m_move;

	//弾の位置更新
	SetPosition(m_pos,D3DXVECTOR3(0.0f, 0.0f, 0.0f));

	//ライフを減らす
	m_nLife--;

	//ライフが0になったら
	if (m_nLife == 0)
	{
		//終了処理
		Uninit();
	}
}